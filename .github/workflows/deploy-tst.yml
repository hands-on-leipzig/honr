name: Deploy to TST

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:  # Allow manual trigger

jobs:
  deploy:
    name: Deploy to Test Environment
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.4'
          extensions: pdo, pdo_mysql, mbstring, xml, curl, zip
          coverage: none

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install Composer dependencies
        working-directory: ./backend
        run: composer install --no-dev --optimize-autoloader --no-interaction

      - name: Build frontend
        working-directory: ./frontend
        env:
          VITE_API_URL: ${{ secrets.TST_API_URL }}
        run: |
          npm ci
          npm run build-only

      - name: Copy frontend dist to backend public
        run: |
          mkdir -p backend/public
          rm -rf backend/public/build
          rm -f backend/public/index.html
          cp -r frontend/dist/* backend/public/

      - name: Setup SSH
        env:
          SSH_KEY: ${{ secrets.TST_SSH_KEY }}
          SSH_USER: ${{ secrets.TST_USER }}
          SSH_HOST: ${{ secrets.TST_HOST }}
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          # Write SSH key - handle different formats
          # Remove any leading/trailing whitespace and ensure proper newlines
          echo "$SSH_KEY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Verify key format
          echo "ðŸ” Verifying SSH key format..."
          KEY_START=$(head -1 ~/.ssh/id_rsa)
          KEY_END=$(tail -1 ~/.ssh/id_rsa)
          
          if echo "$KEY_START" | grep -qE "(BEGIN|OPENSSH)"; then
            echo "âœ… Key starts with: $KEY_START"
          else
            echo "âŒ Key is missing BEGIN marker - check GitHub secret format"
            echo "First line: $KEY_START"
            exit 1
          fi
          
          if echo "$KEY_END" | grep -qE "(END|PRIVATE)"; then
            echo "âœ… Key ends with: $KEY_END"
          else
            echo "âŒ Key is missing END marker - check GitHub secret format"
            echo "Last line: $KEY_END"
            exit 1
          fi
          
          # Detect key type
          if echo "$KEY_START" | grep -q "OPENSSH"; then
            KEY_TYPE="openssh"
            echo "ðŸ” Detected OpenSSH format key"
          elif echo "$KEY_START" | grep -q "RSA"; then
            KEY_TYPE="rsa"
            echo "ðŸ” Detected RSA PEM format key"
          elif echo "$KEY_START" | grep -q "EC"; then
            KEY_TYPE="ec"
            echo "ðŸ” Detected EC PEM format key"
          else
            KEY_TYPE="unknown"
            echo "âš ï¸  Unknown key format, will try to use as-is"
          fi
          
          # Try to extract public key for verification
          echo "ðŸ” Attempting to extract public key..."
          # Try different methods to extract public key
          PUBLIC_KEY_EXTRACTED=false
          
          # Method 1: ssh-keygen -y (works for unencrypted keys)
          if ssh-keygen -y -f ~/.ssh/id_rsa > ~/.ssh/id_rsa.pub 2>/dev/null; then
            PUBLIC_KEY_EXTRACTED=true
            echo "âœ… Public key extracted successfully using ssh-keygen"
          else
            # Method 2: Try with -m PEM for PEM format keys
            if ssh-keygen -y -f ~/.ssh/id_rsa -m PEM > ~/.ssh/id_rsa.pub 2>/dev/null; then
              PUBLIC_KEY_EXTRACTED=true
              echo "âœ… Public key extracted successfully using PEM format"
            fi
          fi
          
          if [ "$PUBLIC_KEY_EXTRACTED" = "true" ]; then
            echo ""
            echo "ðŸ“‹ PUBLIC KEY (add this to server's ~/.ssh/authorized_keys):"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            cat ~/.ssh/id_rsa.pub
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo ""
            echo "ðŸ”‘ Public key fingerprint:"
            ssh-keygen -lf ~/.ssh/id_rsa.pub 2>/dev/null || true
            echo ""
            echo "âš ï¸  IMPORTANT: If SSH connection fails, verify this public key is in:"
            echo "   $SSH_USER@$SSH_HOST:~/.ssh/authorized_keys"
          else
            echo "âš ï¸  Could not extract public key automatically"
            echo "âš ï¸  The key might be encrypted with a passphrase"
            echo ""
            echo "To get the public key manually, run on your local machine:"
            echo "  ssh-keygen -y -f /path/to/your/private/key"
            echo ""
            echo "Then add it to the server's ~/.ssh/authorized_keys file"
          fi
          # Scan for all host keys (RSA, ED25519, ECDSA) and add to known_hosts
          echo "ðŸ” Scanning host keys for $SSH_HOST..."
          ssh-keyscan -H -t rsa,ed25519,ecdsa $SSH_HOST >> ~/.ssh/known_hosts 2>/dev/null || true
          chmod 644 ~/.ssh/known_hosts
          # Verify known_hosts was written
          echo "ðŸ” Known hosts file:"
          cat ~/.ssh/known_hosts
          # Test SSH connection with verbose output for debugging
          echo "ðŸ” Testing SSH connection..."
          ssh -v -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes -o UserKnownHostsFile=~/.ssh/known_hosts -o BatchMode=yes $SSH_USER@$SSH_HOST echo "SSH test successful" 2>&1 || {
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "âŒ SSH AUTHENTICATION FAILED"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo ""
            echo "The server accepted the key format but denied access."
            echo "This means the PUBLIC KEY is not in the server's authorized_keys file."
            echo ""
            echo "ðŸ”‘ Key fingerprint: SHA256:OeOL+jZO8BCnKHUwcKBsGN6ZwqB4hpj4X0oVt+BZSuM"
            echo ""
            echo "ðŸ“‹ TO FIX THIS:"
            echo ""
            echo "Option 1: Add Public Key to Server (Recommended)"
            echo "  1. Extract public key from your private key:"
            echo "     ssh-keygen -y -f /path/to/your/private/key > public_key.pub"
            echo ""
            echo "  2. Add to server's authorized_keys:"
            echo "     cat public_key.pub | ssh $SSH_USER@$SSH_HOST 'mkdir -p ~/.ssh && cat >> ~/.ssh/authorized_keys && chmod 600 ~/.ssh/authorized_keys'"
            echo ""
            echo "Option 2: Use Server-Side Deployment (No SSH needed)"
            echo "  SSH to server manually and run:"
            echo "    cd ${{ secrets.TST_DEPLOY_PATH }}"
            echo "    bash scripts/deploy-from-git.sh tst ${{ secrets.TST_DEPLOY_PATH }} main"
            echo ""
            echo "Option 3: Generate New Unencrypted Key for CI/CD"
            echo "  ssh-keygen -t ed25519 -C 'github-actions' -f ~/.ssh/github_deploy -N ''"
            echo "  # Add github_deploy to TST_SSH_KEY secret"
            echo "  # Add github_deploy.pub to server's authorized_keys"
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            exit 1
          }

      - name: Rsync backend to server
        env:
          SSH_KEY: ${{ secrets.TST_SSH_KEY }}
          SSH_USER: ${{ secrets.TST_USER }}
          SSH_HOST: ${{ secrets.TST_HOST }}
        run: |
          # Create temp directory structure on server
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes -o UserKnownHostsFile=~/.ssh/known_hosts $SSH_USER@$SSH_HOST "mkdir -p ${{ secrets.TST_DEPLOY_PATH }}/releases/temp/backend"
          # Rsync backend files to temp/backend directory
          rsync -avz -e "ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes -o UserKnownHostsFile=~/.ssh/known_hosts" --delete \
            --exclude='.env' \
            --exclude='.git' \
            --exclude='vendor' \
            --exclude='node_modules' \
            --exclude='tests' \
            ./backend/ $SSH_USER@$SSH_HOST:${{ secrets.TST_DEPLOY_PATH }}/releases/temp/backend/

      - name: Finalize deployment on server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.TST_HOST }}
          username: ${{ secrets.TST_USER }}
          key: ${{ secrets.TST_SSH_KEY }}
          script: |
            set -e
            DEPLOY_PATH="${{ secrets.TST_DEPLOY_PATH }}"
            RELEASE_DIR="$DEPLOY_PATH/releases/$(date +%Y%m%d%H%M%S)"
            SHARED_DIR="$DEPLOY_PATH/shared"
            CURRENT_LINK="$DEPLOY_PATH/current"
            TEMP_DIR="$DEPLOY_PATH/releases/temp"
            
            echo "ðŸš€ Starting deployment..."
            echo "Release directory: $RELEASE_DIR"
            
            # Create release directory
            mkdir -p "$RELEASE_DIR"
            
            # Move backend from temp to release directory
            if [ -d "$TEMP_DIR/backend" ]; then
              mv "$TEMP_DIR/backend" "$RELEASE_DIR/"
            else
              echo "âŒ Error: Backend files not found in $TEMP_DIR/backend"
              exit 1
            fi
            
            # Ensure shared directories exist
            mkdir -p "$SHARED_DIR/storage/app/public"
            mkdir -p "$SHARED_DIR/storage/framework/cache"
            mkdir -p "$SHARED_DIR/storage/framework/sessions"
            mkdir -p "$SHARED_DIR/storage/framework/views"
            mkdir -p "$SHARED_DIR/storage/logs"
            mkdir -p "$SHARED_DIR/bootstrap/cache"
            
            # Install Composer dependencies
            cd "$RELEASE_DIR/backend"
            composer install --no-dev --optimize-autoloader --no-interaction
            
            # Link shared storage
            rm -rf storage bootstrap/cache
            ln -sf "$SHARED_DIR/storage" storage
            ln -sf "$SHARED_DIR/bootstrap/cache" bootstrap/cache
            
            # Copy env file
            if [ -f "$SHARED_DIR/.env.tst" ]; then
              cp "$SHARED_DIR/.env.tst" .env
            else
              echo "âš ï¸  Warning: .env.tst not found in $SHARED_DIR"
            fi
            
            # Set permissions
            chmod -R 775 "$SHARED_DIR/storage" || true
            chmod -R 775 "$SHARED_DIR/bootstrap/cache" || true
            chown -R www-data:www-data "$SHARED_DIR/storage" || true
            chown -R www-data:www-data "$SHARED_DIR/bootstrap/cache" || true
            
            # Laravel setup
            php artisan config:cache || true
            php artisan route:cache || true
            php artisan view:cache || true
            php artisan storage:link || true
            
            # Migrations (skip on initial deployment)
            echo "ðŸ“Š Checking database migration status..."
            MIGRATIONS_EXIST=$(php artisan tinker --execute="try { DB::table('migrations')->count(); echo 'true'; } catch (Exception \$e) { echo 'false'; }" 2>/dev/null | tail -1 || echo "false")
            
            if [ "$MIGRATIONS_EXIST" = "true" ]; then
              echo "ðŸ“Š Running database migrations..."
              php artisan migrate --force
            else
              echo "âš ï¸  Skipping migrations (initial deployment or migrations table not found)"
            fi
            
            # Clear and cache config
            php artisan config:clear || true
            php artisan cache:clear || true
            php artisan config:cache || true
            
            # Create symlink to current release
            ln -sfn "$RELEASE_DIR" "$CURRENT_LINK"
            
            # Cleanup temp directory
            rm -rf "$TEMP_DIR"
            
            # Clean up old releases (keep last 5)
            cd "$DEPLOY_PATH/releases"
            ls -t | tail -n +6 | xargs rm -rf 2>/dev/null || true
            
            echo "âœ… Deployment completed!"
            echo "Current release: $RELEASE_DIR"

      - name: Create deployment artifact (fallback)
        if: failure()
        run: |
          echo "âš ï¸  SSH deployment failed. Creating deployment artifact as fallback..."
          mkdir -p deploy-tst
          cp -r backend deploy-tst/
          # Exclude unnecessary files
          rm -rf deploy-tst/backend/vendor
          rm -rf deploy-tst/backend/node_modules
          rm -rf deploy-tst/backend/tests
          rm -rf deploy-tst/backend/.git
          tar -czf deploy-tst.tar.gz deploy-tst/
          
      - name: Upload deployment artifact (fallback)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: tst-deployment-fallback
          path: deploy-tst.tar.gz
          retention-days: 30

      - name: Deployment summary
        run: |
          echo "## ðŸš€ TST Deployment Summary" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" = "success" ]; then
            echo "- **Status**: âœ… Code deployed to TST server" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Status**: âš ï¸  SSH deployment failed - artifact created for manual deployment" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Manual Deployment Required" >> $GITHUB_STEP_SUMMARY
            echo "1. Download the deployment artifact from this run" >> $GITHUB_STEP_SUMMARY
            echo "2. Upload to server: \`scp deploy-tst.tar.gz ${{ secrets.TST_USER }}@${{ secrets.TST_HOST }}:/tmp/\`" >> $GITHUB_STEP_SUMMARY
            echo "3. SSH to server and run: \`bash scripts/deploy-from-git.sh tst ${{ secrets.TST_DEPLOY_PATH }} main\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**OR** use server-side deployment (recommended):" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
            echo "ssh ${{ secrets.TST_USER }}@${{ secrets.TST_HOST }}" >> $GITHUB_STEP_SUMMARY
            echo "cd ${{ secrets.TST_DEPLOY_PATH }}" >> $GITHUB_STEP_SUMMARY
            echo "bash scripts/deploy-from-git.sh tst ${{ secrets.TST_DEPLOY_PATH }} main" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          fi
          echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Time**: $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Verify application at: ${{ secrets.TST_API_URL }}" >> $GITHUB_STEP_SUMMARY

